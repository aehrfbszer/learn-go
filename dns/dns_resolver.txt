package main

import (
	"crypto/tls"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"log"
	"net"
	"net/http"
	"os"
	"os/signal"
	"path/filepath"
	"strconv"
	"strings"
	"syscall"
	"time"

	"github.com/miekg/dns"
)

// 服务配置
type ServiceConfig struct {
	ListenAddr    string
	ListenPort    int
	Protocol      string // "tcp", "udp" or "both"
	Background    bool
	PidFile       string
	LogFile       string
	DefaultQuery  string // 默认查询类型
	DefaultServer string // 默认DNS服务器
	DoHEndpoint   string
}

// DNS查询类型
const (
	QueryTypeNormal = "normal"
	QueryTypeDoH    = "doh"
	QueryTypeDoT    = "dot"
)

// DNS记录类型
const (
	RecordTypeA     = "A"
	RecordTypeAAAA  = "AAAA"
	RecordTypeCNAME = "CNAME"
	RecordTypeMX    = "MX"
	RecordTypeNS    = "NS"
	RecordTypeTXT   = "TXT"
)

var config ServiceConfig
var logger *log.Logger

func main() {
	// 解析命令行参数
	parseFlags()

	// 初始化日志
	initLogger()

	// 如果需要后台运行
	if config.Background {
		if err := daemonize(); err != nil {
			logger.Fatalf("无法在后台运行: %v", err)
		}
	}

	// 写入PID文件
	if config.PidFile != "" {
		if err := writePidFile(config.PidFile); err != nil {
			logger.Fatalf("无法写入PID文件: %v", err)
		}
		defer os.Remove(config.PidFile)
	}

	// 设置信号处理
	setupSignalHandler()

	logger.Printf("DNS解析服务启动，监听 %s:%d (%s)",
		config.ListenAddr, config.ListenPort, config.Protocol)

	// 启动服务器
	startServer()
}

// 解析命令行参数
func parseFlags() {
	config = ServiceConfig{
		ListenAddr:    "0.0.0.0",
		ListenPort:    5353,
		Protocol:      "both",
		Background:    false,
		PidFile:       "/var/run/dnsresolver.pid",
		LogFile:       "/var/log/dnsresolver.log",
		DefaultQuery:  QueryTypeNormal,
		DefaultServer: "8.8.8.8",
		DoHEndpoint:   "https://cloudflare-dns.com/dns-query",
	}

	flag.StringVar(&config.ListenAddr, "addr", config.ListenAddr, "监听地址")
	flag.IntVar(&config.ListenPort, "port", config.ListenPort, "监听端口")
	flag.StringVar(&config.Protocol, "proto", config.Protocol, "协议类型 (tcp, udp, both)")
	flag.BoolVar(&config.Background, "background", config.Background, "后台运行")
	flag.StringVar(&config.PidFile, "pid", config.PidFile, "PID文件路径")
	flag.StringVar(&config.LogFile, "log", config.LogFile, "日志文件路径")
	flag.StringVar(&config.DefaultQuery, "default-query", config.DefaultQuery, "默认查询类型")
	flag.StringVar(&config.DefaultServer, "default-server", config.DefaultServer, "默认DNS服务器")
	flag.StringVar(&config.DoHEndpoint, "doh-endpoint", config.DoHEndpoint, "默认DoH端点")

	flag.Parse()
}

// 初始化日志
func initLogger() {
	var logOutput io.Writer

	if config.LogFile != "" {
		// 确保日志目录存在
		logDir := filepath.Dir(config.LogFile)
		if err := os.MkdirAll(logDir, 0755); err != nil {
			fmt.Printf("无法创建日志目录: %v\n", err)
			os.Exit(1)
		}

		// 打开日志文件
		logFile, err := os.OpenFile(config.LogFile, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
		if err != nil {
			fmt.Printf("无法打开日志文件: %v\n", err)
			os.Exit(1)
		}
		logOutput = logFile
	} else {
		logOutput = os.Stdout
	}

	logger = log.New(logOutput, "", log.Ldate|log.Ltime|log.Lmicroseconds|log.Lshortfile)
}

// 后台运行
func daemonize() error {
	// 实现Unix风格的daemon化
	// 第一次fork
	pid, err := syscall.ForkExec(os.Args[0], os.Args, &syscall.ProcAttr{
		Env:   os.Environ(),
		Files: []uintptr{os.Stdin.Fd(), os.Stdout.Fd(), os.Stderr.Fd()},
	})
	if err != nil {
		return err
	}
	if pid > 0 {
		os.Exit(0)
	}

	// 设置新的会话
	syscall.Setsid()

	// 第二次fork，确保不能获取终端
	pid, err = syscall.ForkExec(os.Args[0], os.Args, &syscall.ProcAttr{
		Env:   os.Environ(),
		Files: []uintptr{os.Stdin.Fd(), os.Stdout.Fd(), os.Stderr.Fd()},
	})
	if err != nil {
		return err
	}
	if pid > 0 {
		os.Exit(0)
	}

	// 切换到根目录
	os.Chdir("/")

	// 关闭标准输入输出
	os.Stdin.Close()
	os.Stdout.Close()
	os.Stderr.Close()

	return nil
}

// 写入PID文件
func writePidFile(path string) error {
	pid := os.Getpid()
	content := []byte(fmt.Sprintf("%d\n", pid))
	return os.WriteFile(path, content, 0644)
}

// 设置信号处理
func setupSignalHandler() {
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM, syscall.SIGHUP)

	go func() {
		sig := <-sigChan
		logger.Printf("收到信号 %s，正在关闭服务...", sig)

		// 可以在这里添加清理代码

		os.Exit(0)
	}()
}

// 启动服务器
func startServer() {
	// 注册DNS处理函数
	dns.HandleFunc(".", handleDNSRequest)

	// 启动UDP服务器
	if config.Protocol == "udp" || config.Protocol == "both" {
		go func() {
			server := &dns.Server{
				Addr:    fmt.Sprintf("%s:%d", config.ListenAddr, config.ListenPort),
				Net:     "udp",
				Handler: dns.DefaultServeMux,
				UDPSize: 4096,
			}

			logger.Printf("UDP服务器启动在 %s", server.Addr)
			if err := server.ListenAndServe(); err != nil {
				logger.Fatalf("UDP服务器失败: %v", err)
			}
		}()
	}

	// 启动TCP服务器
	if config.Protocol == "tcp" || config.Protocol == "both" {
		go func() {
			server := &dns.Server{
				Addr:    fmt.Sprintf("%s:%d", config.ListenAddr, config.ListenPort),
				Net:     "tcp",
				Handler: dns.DefaultServeMux,
			}

			logger.Printf("TCP服务器启动在 %s", server.Addr)
			if err := server.ListenAndServe(); err != nil {
				logger.Fatalf("TCP服务器失败: %v", err)
			}
		}()
	}

	// 保持主进程运行
	select {}
}

// 处理DNS请求
func handleDNSRequest(w dns.ResponseWriter, r *dns.Msg) {
	// 每个请求在单独的goroutine中处理，实现并发
	go func() {
		startTime := time.Now()
		clientIP, _, _ := net.SplitHostPort(w.RemoteAddr().String())

		// 记录请求信息
		var domain string
		var qtype string
		if len(r.Question) > 0 {
			domain = r.Question[0].Name
			qtype = dns.TypeToString[r.Question[0].Qtype]
			logger.Printf("收到请求: %s %s 来自 %s", domain, qtype, clientIP)
		}

		// 创建响应
		m := new(dns.Msg)
		m.SetReply(r)
		m.Compress = false

		// 处理请求
		if len(r.Question) == 0 {
			m.Rcode = dns.RcodeFormatError
		} else {
			// 调用解析函数获取结果
			answers, err := resolveDomain(
				strings.TrimSuffix(r.Question[0].Name, "."),
				dns.TypeToString[r.Question[0].Qtype],
				config.DefaultQuery,
				config.DefaultServer,
				config.DoHEndpoint,
			)

			if err != nil {
				logger.Printf("解析错误: %v", err)
				m.Rcode = dns.RcodeServerFailure
			} else {
				m.Answer = answers
			}
		}

		// 发送响应
		if err := w.WriteMsg(m); err != nil {
			logger.Printf("发送响应失败: %v", err)
		}

		// 记录处理时间
		logger.Printf("处理完成: %s %s 耗时 %v", domain, qtype, time.Since(startTime))
	}()
}

// 解析域名（核心解析函数）
func resolveDomain(domain, recordType, queryType, dnsServer, dohEndpoint string) ([]dns.RR, error) {
	switch queryType {
	case QueryTypeNormal:
		return resolveNormal(domain, recordType, dnsServer)
	case QueryTypeDoH:
		return resolveDoH(domain, recordType, dohEndpoint)
	case QueryTypeDoT:
		return resolveDoT(domain, recordType, dnsServer)
	default:
		return resolveNormal(domain, recordType, dnsServer)
	}
}

// 检查是否为IPv6地址
func isIPv6(address string) bool {
	return strings.Count(address, ":") >= 2
}

// 普通DNS查询
func resolveNormal(domain, recordType, dnsServer string) ([]dns.RR, error) {
	// 处理服务器地址
	formattedServer := dnsServer
	if !strings.Contains(dnsServer, ":") {
		formattedServer += ":53"
	} else if isIPv6(dnsServer) && !strings.HasPrefix(dnsServer, "[") {
		formattedServer = "[" + dnsServer + "]:53"
	}

	// 创建DNS客户端
	c := dns.Client{
		Timeout: 5 * time.Second,
	}
	msg := dns.Msg{}
	msg.SetQuestion(dns.Fqdn(domain), getRRType(recordType))
	msg.RecursionDesired = true

	// 发送查询
	r, _, err := c.Exchange(&msg, formattedServer)
	if err != nil {
		return nil, err
	}

	// 检查是否有错误
	if r.Rcode != dns.RcodeSuccess {
		return nil, fmt.Errorf("查询返回错误代码: %d", r.Rcode)
	}

	return r.Answer, nil
}

// DoH (DNS over HTTPS) 查询
func resolveDoH(domain, recordType, dohEndpoint string) ([]dns.RR, error) {
	// 创建DNS消息
	msg := dns.Msg{}
	msg.SetQuestion(dns.Fqdn(domain), getRRType(recordType))
	msg.RecursionDesired = true

	// 序列化消息
	buf, err := msg.Pack()
	if err != nil {
		return nil, err
	}

	// 构建查询URL
	url := fmt.Sprintf("%s?name=%s&type=%s", dohEndpoint, dns.Fqdn(domain), recordType)

	// 发送HTTPS请求
	client := &http.Client{
		Timeout: 10 * time.Second,
	}
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, err
	}
	req.Header.Set("Accept", "application/dns-json")

	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	// 解析响应
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	// 解析JSON响应
	var dohResponse map[string]interface{}
	if err := json.Unmarshal(body, &dohResponse); err != nil {
		return nil, err
	}

	// 检查错误
	if status, ok := dohResponse["Status"].(float64); ok && status != 0 {
		return nil, fmt.Errorf("DoH查询返回错误: 状态码 %d", int(status))
	}

	// 转换为dns.RR格式
	var answers []dns.RR
	if answerList, ok := dohResponse["Answer"].([]interface{}); ok {
		for _, ans := range answerList {
			answer := ans.(map[string]interface{})

			rrType, _ := answer["type"].(float64)
			rrName := answer["name"].(string)
			rrData := answer["data"].(string)
			rrTTL := uint32(answer["TTL"].(float64))

			// 根据类型创建相应的RR记录
			var rr dns.RR
			switch uint16(rrType) {
			case dns.TypeA:
				rr, _ = dns.NewRR(fmt.Sprintf("%s %d IN A %s", rrName, rrTTL, rrData))
			case dns.TypeAAAA:
				rr, _ = dns.NewRR(fmt.Sprintf("%s %d IN AAAA %s", rrName, rrTTL, rrData))
			case dns.TypeCNAME:
				rr, _ = dns.NewRR(fmt.Sprintf("%s %d IN CNAME %s", rrName, rrTTL, rrData))
			case dns.TypeMX:
				// MX记录格式特殊，需要解析优先级
				mxParts := strings.Split(rrData, " ")
				if len(mxParts) == 2 {
					pref, _ := strconv.Atoi(mxParts[0])
					rr, _ = dns.NewRR(fmt.Sprintf("%s %d IN MX %d %s", rrName, rrTTL, pref, mxParts[1]))
				}
			case dns.TypeNS:
				rr, _ = dns.NewRR(fmt.Sprintf("%s %d IN NS %s", rrName, rrTTL, rrData))
			case dns.TypeTXT:
				rr, _ = dns.NewRR(fmt.Sprintf("%s %d IN TXT %s", rrName, rrTTL, rrData))
			}

			if rr != nil {
				answers = append(answers, rr)
			}
		}
	}

	return answers, nil
}

// DoT (DNS over TLS) 查询
func resolveDoT(domain, recordType, dnsServer string) ([]dns.RR, error) {
	// 处理服务器地址
	formattedServer := dnsServer
	if !strings.Contains(dnsServer, ":") {
		formattedServer += ":853"
	} else if isIPv6(dnsServer) && !strings.HasPrefix(dnsServer, "[") {
		formattedServer = "[" + dnsServer + "]:853"
	}

	// 创建TLS连接
	conn, err := tls.DialWithDialer(&net.Dialer{Timeout: 5 * time.Second},
		"tcp", formattedServer, &tls.Config{
			InsecureSkipVerify: false,
			ServerName:         strings.Split(formattedServer, ":")[0],
		})
	if err != nil {
		return nil, err
	}
	defer conn.Close()

	// 创建DNS消息
	msg := dns.Msg{}
	msg.SetQuestion(dns.Fqdn(domain), getRRType(recordType))
	msg.RecursionDesired = true

	// 发送DNS查询
	buf, err := msg.Pack()
	if err != nil {
		return nil, err
	}

	// 前两个字节是消息长度
	length := []byte{byte(len(buf) >> 8), byte(len(buf) & 0xff)}
	_, err = conn.Write(append(length, buf...))
	if err != nil {
		return nil, err
	}

	// 读取响应
	respLength := make([]byte, 2)
	_, err = conn.Read(respLength)
	if err != nil {
		return nil, err
	}

	respBuf := make([]byte, int(respLength[0])<<8|int(respLength[1]))
	_, err = conn.Read(respBuf)
	if err != nil {
		return nil, err
	}

	// 解析响应
	var response dns.Msg
	if err := response.Unpack(respBuf); err != nil {
		return nil, err
	}

	// 检查是否有错误
	if response.Rcode != dns.RcodeSuccess {
		return nil, fmt.Errorf("DoT查询返回错误代码: %d", response.Rcode)
	}

	return response.Answer, nil
}

// 转换记录类型字符串为dns包中的常量
func getRRType(recordType string) uint16 {
	switch strings.ToUpper(recordType) {
	case RecordTypeA:
		return dns.TypeA
	case RecordTypeAAAA:
		return dns.TypeAAAA
	case RecordTypeCNAME:
		return dns.TypeCNAME
	case RecordTypeMX:
		return dns.TypeMX
	case RecordTypeNS:
		return dns.TypeNS
	case RecordTypeTXT:
		return dns.TypeTXT
	default:
		return dns.TypeA // 默认查询A记录
	}
}
